{"version":3,"file":"SplitText.min.js","sources":["../src/SplitText.js"],"sourcesContent":["/*!\n * SplitText 3.14.1\n * https://gsap.com\n *\n * @license Copyright 2025, GreenSock. All rights reserved. Subject to the terms at https://gsap.com/standard-license.\n * @author: Jack Doyle\n */\n\nlet gsap, _fonts, _coreInitted, _initIfNecessary = () => _coreInitted || SplitText.register(window.gsap), _charSegmenter = typeof Intl !== \"undefined\" && \"Segmenter\" in Intl ? new Intl.Segmenter() : 0, _toArray = (r) => typeof r === \"string\" ? _toArray(document.querySelectorAll(r)) : \"length\" in r ? Array.from(r) : [r], _elements = (targets) => _toArray(targets).filter((e) => e instanceof HTMLElement), _emptyArray = [], _context = function() {\n}, _defaultContext = { add: (f) => f() }, _spacesRegEx = /\\s+/g, _emojiSafeRegEx = new RegExp(\"\\\\p{RI}\\\\p{RI}|\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?(\\\\u{200D}\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?)*|.\", \"gu\"), _emptyBounds = { left: 0, top: 0, width: 0, height: 0 }, _findNextValidBounds = (allBounds, startIndex) => {\n  while (++startIndex < allBounds.length && allBounds[startIndex] === _emptyBounds) {\n  }\n  return allBounds[startIndex] || _emptyBounds;\n}, _stretchToFitSpecialChars = (collection, specialCharsRegEx) => {\n  if (specialCharsRegEx) {\n    let charsFound = new Set(collection.join(\"\").match(specialCharsRegEx) || _emptyArray), i = collection.length, slots, word, char, combined;\n    if (charsFound.size) {\n      while (--i > -1) {\n        word = collection[i];\n        for (char of charsFound) {\n          if (char.startsWith(word) && char.length > word.length) {\n            slots = 0;\n            combined = word;\n            while (char.startsWith(combined += collection[i + ++slots]) && combined.length < char.length) {\n            }\n            if (slots && combined.length === char.length) {\n              collection[i] = char;\n              collection.splice(i + 1, slots);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n  return collection;\n}, _disallowInline = (element) => window.getComputedStyle(element).display === \"inline\" && (element.style.display = \"inline-block\"), _insertNodeBefore = (newChild, parent, existingChild) => parent.insertBefore(typeof newChild === \"string\" ? document.createTextNode(newChild) : newChild, existingChild), _getWrapper = (type, config, collection) => {\n  let className = config[type + \"sClass\"] || \"\", { tag = \"div\", aria = \"auto\", propIndex = false } = config, display = type === \"line\" ? \"block\" : \"inline-block\", incrementClass = className.indexOf(\"++\") > -1, wrapper = (text) => {\n    let el = document.createElement(tag), i = collection.length + 1;\n    className && (el.className = className + (incrementClass ? \" \" + className + i : \"\"));\n    propIndex && el.style.setProperty(\"--\" + type, i + \"\");\n    aria !== \"none\" && el.setAttribute(\"aria-hidden\", \"true\");\n    if (tag !== \"span\") {\n      el.style.position = \"relative\";\n      el.style.display = display;\n    }\n    el.textContent = text;\n    collection.push(el);\n    return el;\n  };\n  incrementClass && (className = className.replace(\"++\", \"\"));\n  wrapper.collection = collection;\n  return wrapper;\n}, _getLineWrapper = (element, nodes, config, collection) => {\n  let lineWrapper = _getWrapper(\"line\", config, collection), textAlign = window.getComputedStyle(element).textAlign || \"left\";\n  return (startIndex, endIndex) => {\n    let newLine = lineWrapper(\"\");\n    newLine.style.textAlign = textAlign;\n    element.insertBefore(newLine, nodes[startIndex]);\n    for (; startIndex < endIndex; startIndex++) {\n      newLine.appendChild(nodes[startIndex]);\n    }\n    newLine.normalize();\n  };\n}, _splitWordsAndCharsRecursively = (element, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, isNested) => {\n  var _a;\n  let nodes = Array.from(element.childNodes), i = 0, { wordDelimiter, reduceWhiteSpace = true, prepareText } = config, elementBounds = element.getBoundingClientRect(), lastBounds = elementBounds, isPreformatted = !reduceWhiteSpace && window.getComputedStyle(element).whiteSpace.substring(0, 3) === \"pre\", ignoredPreviousSibling = 0, wordsCollection = wordWrapper.collection, wordDelimIsNotSpace, wordDelimString, wordDelimSplitter, curNode, words, curWordEl, startsWithSpace, endsWithSpace, j, bounds, curWordChars, clonedNode, curSubNode, tempSubNode, curTextContent, wordText, lastWordText, k;\n  if (typeof wordDelimiter === \"object\") {\n    wordDelimSplitter = wordDelimiter.delimiter || wordDelimiter;\n    wordDelimString = wordDelimiter.replaceWith || \"\";\n  } else {\n    wordDelimString = wordDelimiter === \"\" ? \"\" : wordDelimiter || \" \";\n  }\n  wordDelimIsNotSpace = wordDelimString !== \" \";\n  for (; i < nodes.length; i++) {\n    curNode = nodes[i];\n    if (curNode.nodeType === 3) {\n      curTextContent = curNode.textContent || \"\";\n      if (reduceWhiteSpace) {\n        curTextContent = curTextContent.replace(_spacesRegEx, \" \");\n      } else if (isPreformatted) {\n        curTextContent = curTextContent.replace(/\\n/g, wordDelimString + \"\\n\");\n      }\n      prepareText && (curTextContent = prepareText(curTextContent, element));\n      curNode.textContent = curTextContent;\n      words = wordDelimString || wordDelimSplitter ? curTextContent.split(wordDelimSplitter || wordDelimString) : curTextContent.match(charSplitRegEx) || _emptyArray;\n      lastWordText = words[words.length - 1];\n      endsWithSpace = wordDelimIsNotSpace ? lastWordText.slice(-1) === \" \" : !lastWordText;\n      lastWordText || words.pop();\n      lastBounds = elementBounds;\n      startsWithSpace = wordDelimIsNotSpace ? words[0].charAt(0) === \" \" : !words[0];\n      startsWithSpace && _insertNodeBefore(\" \", element, curNode);\n      words[0] || words.shift();\n      _stretchToFitSpecialChars(words, specialCharsRegEx);\n      deepSlice && isNested || (curNode.textContent = \"\");\n      for (j = 1; j <= words.length; j++) {\n        wordText = words[j - 1];\n        if (!reduceWhiteSpace && isPreformatted && wordText.charAt(0) === \"\\n\") {\n          (_a = curNode.previousSibling) == null ? void 0 : _a.remove();\n          _insertNodeBefore(document.createElement(\"br\"), element, curNode);\n          wordText = wordText.slice(1);\n        }\n        if (!reduceWhiteSpace && wordText === \"\") {\n          _insertNodeBefore(wordDelimString, element, curNode);\n        } else if (wordText === \" \") {\n          element.insertBefore(document.createTextNode(\" \"), curNode);\n        } else {\n          wordDelimIsNotSpace && wordText.charAt(0) === \" \" && _insertNodeBefore(\" \", element, curNode);\n          if (ignoredPreviousSibling && j === 1 && !startsWithSpace && wordsCollection.indexOf(ignoredPreviousSibling.parentNode) > -1) {\n            curWordEl = wordsCollection[wordsCollection.length - 1];\n            curWordEl.appendChild(document.createTextNode(charWrapper ? \"\" : wordText));\n          } else {\n            curWordEl = wordWrapper(charWrapper ? \"\" : wordText);\n            _insertNodeBefore(curWordEl, element, curNode);\n            ignoredPreviousSibling && j === 1 && !startsWithSpace && curWordEl.insertBefore(ignoredPreviousSibling, curWordEl.firstChild);\n          }\n          if (charWrapper) {\n            curWordChars = _charSegmenter ? _stretchToFitSpecialChars([..._charSegmenter.segment(wordText)].map((s) => s.segment), specialCharsRegEx) : wordText.match(charSplitRegEx) || _emptyArray;\n            for (k = 0; k < curWordChars.length; k++) {\n              curWordEl.appendChild(curWordChars[k] === \" \" ? document.createTextNode(\" \") : charWrapper(curWordChars[k]));\n            }\n          }\n          if (deepSlice && isNested) {\n            curTextContent = curNode.textContent = curTextContent.substring(wordText.length + 1, curTextContent.length);\n            bounds = curWordEl.getBoundingClientRect();\n            if (bounds.top > lastBounds.top && bounds.left <= lastBounds.left) {\n              clonedNode = element.cloneNode();\n              curSubNode = element.childNodes[0];\n              while (curSubNode && curSubNode !== curWordEl) {\n                tempSubNode = curSubNode;\n                curSubNode = curSubNode.nextSibling;\n                clonedNode.appendChild(tempSubNode);\n              }\n              element.parentNode.insertBefore(clonedNode, element);\n              prepForCharsOnly && _disallowInline(clonedNode);\n            }\n            lastBounds = bounds;\n          }\n          if (j < words.length || endsWithSpace) {\n            _insertNodeBefore(j >= words.length ? \" \" : wordDelimIsNotSpace && wordText.slice(-1) === \" \" ? \" \" + wordDelimString : wordDelimString, element, curNode);\n          }\n        }\n      }\n      element.removeChild(curNode);\n      ignoredPreviousSibling = 0;\n    } else if (curNode.nodeType === 1) {\n      if (ignore && ignore.indexOf(curNode) > -1) {\n        wordsCollection.indexOf(curNode.previousSibling) > -1 && wordsCollection[wordsCollection.length - 1].appendChild(curNode);\n        ignoredPreviousSibling = curNode;\n      } else {\n        _splitWordsAndCharsRecursively(curNode, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, true);\n        ignoredPreviousSibling = 0;\n      }\n      prepForCharsOnly && _disallowInline(curNode);\n    }\n  }\n};\nconst _SplitText = class _SplitText {\n  constructor(elements, config) {\n    this.isSplit = false;\n    _initIfNecessary();\n    this.elements = _elements(elements);\n    this.chars = [];\n    this.words = [];\n    this.lines = [];\n    this.masks = [];\n    this.vars = config;\n    this._split = () => this.isSplit && this.split(this.vars);\n    let orig = [], timerId, checkWidths = () => {\n      let i = orig.length, o;\n      while (i--) {\n        o = orig[i];\n        let w = o.element.offsetWidth;\n        if (w !== o.width) {\n          o.width = w;\n          this._split();\n          return;\n        }\n      }\n    };\n    this._data = { orig, obs: typeof ResizeObserver !== \"undefined\" && new ResizeObserver(() => {\n      clearTimeout(timerId);\n      timerId = setTimeout(checkWidths, 200);\n    }) };\n    _context(this);\n    this.split(config);\n  }\n  split(config) {\n    (this._ctx || _defaultContext).add(() => {\n      this.isSplit && this.revert();\n      this.vars = config = config || this.vars || {};\n      let { type = \"chars,words,lines\", aria = \"auto\", deepSlice = true, smartWrap, onSplit, autoSplit = false, specialChars, mask } = this.vars, splitLines = type.indexOf(\"lines\") > -1, splitCharacters = type.indexOf(\"chars\") > -1, splitWords = type.indexOf(\"words\") > -1, onlySplitCharacters = splitCharacters && !splitWords && !splitLines, specialCharsRegEx = specialChars && (\"push\" in specialChars ? new RegExp(\"(?:\" + specialChars.join(\"|\") + \")\", \"gu\") : specialChars), finalCharSplitRegEx = specialCharsRegEx ? new RegExp(specialCharsRegEx.source + \"|\" + _emojiSafeRegEx.source, \"gu\") : _emojiSafeRegEx, ignore = !!config.ignore && _elements(config.ignore), { orig, animTime, obs } = this._data, onSplitResult;\n      if (splitCharacters || splitWords || splitLines) {\n        this.elements.forEach((element, index) => {\n          orig[index] = {\n            element,\n            html: element.innerHTML,\n            ariaL: element.getAttribute(\"aria-label\"),\n            ariaH: element.getAttribute(\"aria-hidden\")\n          };\n          aria === \"auto\" ? element.setAttribute(\"aria-label\", (element.textContent || \"\").trim()) : aria === \"hidden\" && element.setAttribute(\"aria-hidden\", \"true\");\n          let chars = [], words = [], lines = [], charWrapper = splitCharacters ? _getWrapper(\"char\", config, chars) : null, wordWrapper = _getWrapper(\"word\", config, words), i, curWord, smartWrapSpan, nextSibling;\n          _splitWordsAndCharsRecursively(element, config, wordWrapper, charWrapper, onlySplitCharacters, deepSlice && (splitLines || onlySplitCharacters), ignore, finalCharSplitRegEx, specialCharsRegEx, false);\n          if (splitLines) {\n            let nodes = _toArray(element.childNodes), wrapLine = _getLineWrapper(element, nodes, config, lines), curNode, toRemove = [], lineStartIndex = 0, allBounds = nodes.map((n) => n.nodeType === 1 ? n.getBoundingClientRect() : _emptyBounds), lastBounds = _emptyBounds, curBounds;\n            for (i = 0; i < nodes.length; i++) {\n              curNode = nodes[i];\n              if (curNode.nodeType === 1) {\n                if (curNode.nodeName === \"BR\") {\n                  if (!i || nodes[i - 1].nodeName !== \"BR\") {\n                    toRemove.push(curNode);\n                    wrapLine(lineStartIndex, i + 1);\n                  }\n                  lineStartIndex = i + 1;\n                  lastBounds = _findNextValidBounds(allBounds, i);\n                } else {\n                  curBounds = allBounds[i];\n                  if (i && curBounds.top > lastBounds.top && curBounds.left < lastBounds.left + lastBounds.width - 1) {\n                    wrapLine(lineStartIndex, i);\n                    lineStartIndex = i;\n                  }\n                  lastBounds = curBounds;\n                }\n              }\n            }\n            lineStartIndex < i && wrapLine(lineStartIndex, i);\n            toRemove.forEach((el) => {\n              var _a;\n              return (_a = el.parentNode) == null ? void 0 : _a.removeChild(el);\n            });\n          }\n          if (!splitWords) {\n            for (i = 0; i < words.length; i++) {\n              curWord = words[i];\n              if (splitCharacters || !curWord.nextSibling || curWord.nextSibling.nodeType !== 3) {\n                if (smartWrap && !splitLines) {\n                  smartWrapSpan = document.createElement(\"span\");\n                  smartWrapSpan.style.whiteSpace = \"nowrap\";\n                  while (curWord.firstChild) {\n                    smartWrapSpan.appendChild(curWord.firstChild);\n                  }\n                  curWord.replaceWith(smartWrapSpan);\n                } else {\n                  curWord.replaceWith(...curWord.childNodes);\n                }\n              } else {\n                nextSibling = curWord.nextSibling;\n                if (nextSibling && nextSibling.nodeType === 3) {\n                  nextSibling.textContent = (curWord.textContent || \"\") + (nextSibling.textContent || \"\");\n                  curWord.remove();\n                }\n              }\n            }\n            words.length = 0;\n            element.normalize();\n          }\n          this.lines.push(...lines);\n          this.words.push(...words);\n          this.chars.push(...chars);\n        });\n        mask && this[mask] && this.masks.push(...this[mask].map((el) => {\n          let maskEl = el.cloneNode();\n          el.replaceWith(maskEl);\n          maskEl.appendChild(el);\n          el.className && (maskEl.className = el.className.trim() + \"-mask\");\n          maskEl.style.overflow = \"clip\";\n          return maskEl;\n        }));\n      }\n      this.isSplit = true;\n      _fonts && splitLines && (autoSplit ? _fonts.addEventListener(\"loadingdone\", this._split) : _fonts.status === \"loading\" && console.warn(\"SplitText called before fonts loaded\"));\n      if ((onSplitResult = onSplit && onSplit(this)) && onSplitResult.totalTime) {\n        this._data.anim = animTime ? onSplitResult.totalTime(animTime) : onSplitResult;\n      }\n      splitLines && autoSplit && this.elements.forEach((element, index) => {\n        orig[index].width = element.offsetWidth;\n        obs && obs.observe(element);\n      });\n    });\n    return this;\n  }\n  kill() {\n    let { obs } = this._data;\n    obs && obs.disconnect();\n    _fonts == null ? void 0 : _fonts.removeEventListener(\"loadingdone\", this._split);\n  }\n  revert() {\n    var _a, _b;\n    let { orig, anim } = this._data;\n    this.kill();\n    orig.forEach(({ element, html, ariaL, ariaH }) => {\n      element.innerHTML = html;\n      ariaL ? element.setAttribute(\"aria-label\", ariaL) : element.removeAttribute(\"aria-label\");\n      ariaH ? element.setAttribute(\"aria-hidden\", ariaH) : element.removeAttribute(\"aria-hidden\");\n    });\n    this.chars.length = this.words.length = this.lines.length = orig.length = this.masks.length = 0;\n    this.isSplit = false;\n    if (anim) {\n      this._data.animTime = anim.totalTime();\n      anim.revert();\n    }\n    (_b = (_a = this.vars).onRevert) == null ? void 0 : _b.call(_a, this);\n    return this;\n  }\n  static create(elements, config) {\n    return new _SplitText(elements, config);\n  }\n  static register(core) {\n    gsap = gsap || core || window.gsap;\n    if (gsap) {\n      _toArray = gsap.utils.toArray;\n      _context = gsap.core.context || _context;\n    }\n    if (!_coreInitted && window.innerWidth > 0) {\n      _fonts = document.fonts;\n      _coreInitted = true;\n    }\n  }\n};\n_SplitText.version = \"3.14.2\";\nlet SplitText = _SplitText;\n\nexport { SplitText, SplitText as default };\n"],"names":["_elements","targets","_toArray","filter","e","HTMLElement","_findNextValidBounds","allBounds","startIndex","length","_emptyBounds","_stretchToFitSpecialChars","collection","specialCharsRegEx","slots","word","char","combined","charsFound","Set","join","match","_emptyArray","i","size","startsWith","splice","_disallowInline","element","window","getComputedStyle","display","style","_insertNodeBefore","newChild","parent","existingChild","insertBefore","document","createTextNode","_getWrapper","type","config","wrapper","text","el","createElement","tag","className","incrementClass","propIndex","setProperty","aria","setAttribute","position","textContent","push","indexOf","replace","gsap","_fonts","_coreInitted","_charSegmenter","Intl","Segmenter","r","querySelectorAll","Array","from","_context","_defaultContext","add","f","_spacesRegEx","_emojiSafeRegEx","RegExp","left","top","width","height","_SplitText","split","this","_ctx","_this2","isSplit","revert","vars","onSplitResult","deepSlice","smartWrap","onSplit","autoSplit","specialChars","mask","splitLines","splitCharacters","splitWords","onlySplitCharacters","finalCharSplitRegEx","source","ignore","_data","orig","animTime","obs","elements","forEach","index","html","innerHTML","ariaL","getAttribute","ariaH","trim","curWord","smartWrapSpan","nextSibling","chars","words","lines","charWrapper","wordWrapper","_splitWordsAndCharsRecursively","prepForCharsOnly","charSplitRegEx","isNested","_a","wordDelimIsNotSpace","wordDelimString","wordDelimSplitter","curNode","curWordEl","startsWithSpace","endsWithSpace","j","bounds","curWordChars","clonedNode","curSubNode","tempSubNode","curTextContent","wordText","lastWordText","k","nodes","childNodes","wordDelimiter","reduceWhiteSpace","prepareText","elementBounds","getBoundingClientRect","lastBounds","isPreformatted","whiteSpace","substring","ignoredPreviousSibling","wordsCollection","delimiter","replaceWith","nodeType","slice","pop","charAt","shift","previousSibling","remove","parentNode","appendChild","firstChild","segment","map","s","cloneNode","removeChild","curBounds","wrapLine","_getLineWrapper","lineWrapper","textAlign","endIndex","newLine","normalize","toRemove","lineStartIndex","n","nodeName","masks","maskEl","overflow","addEventListener","_split","status","console","warn","totalTime","anim","offsetWidth","observe","kill","disconnect","removeEventListener","_b","removeAttribute","onRevert","call","create","register","core","utils","toArray","context","innerWidth","fonts","_initIfNecessary","SplitText","_this","checkWidths","o","w","timerId","ResizeObserver","clearTimeout","setTimeout","version"],"mappings":"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"}